// Code generated by go generate via internal/cmd/service; DO NOT EDIT.
package qingstor

import (
	"context"
	"io"

	"github.com/aos-dev/go-storage/v2/pkg/credential"
	"github.com/aos-dev/go-storage/v2/pkg/endpoint"
	"github.com/aos-dev/go-storage/v2/pkg/httpclient"
	"github.com/aos-dev/go-storage/v2/services"
	. "github.com/aos-dev/go-storage/v2/types"
)

var _ credential.Provider
var _ endpoint.Provider
var _ Storager
var _ services.ServiceError
var _ httpclient.Options

// Type is the type for qingstor
const Type = "qingstor"

// Service available pairs.
const (
	// DisableURICleaning
	pairDisableURICleaning = "qingstor_disable_uri_cleaning"
)

// WithDisableURICleaning will apply disable_uri_cleaning value to Options
// DisableURICleaning
func WithDisableURICleaning(v bool) Pair {
	return Pair{
		Key:   pairDisableURICleaning,
		Value: v,
	}
}

// GetStorageClass will get storage-class value from metadata.
func GetStorageClass(m *Object) (string, bool) {
	v, ok := m.Get("qingstor-storage-class")
	if !ok {
		return "", false
	}
	return v.(string), true
}

// setstorage-class will set storage-class value into metadata.
func setStorageClass(m *Object, v string) *Object {
	return m.Set("qingstor-storage-class", v)
}

// pairServiceNew is the parsed struct
type pairServiceNew struct {
	pairs []Pair

	// Required pairs
	HasCredential bool
	Credential    *credential.Provider
	// Optional pairs
	HasEndpoint          bool
	Endpoint             endpoint.Provider
	HasHTTPClientOptions bool
	HTTPClientOptions    *httpclient.Options
	HasPairPolicy        bool
	PairPolicy           PairPolicy
	// Generated pairs
}

// parsePairServiceNew will parse Pair slice into *pairServiceNew
func parsePairServiceNew(opts []Pair) (*pairServiceNew, error) {
	result := &pairServiceNew{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		case "credential":
			result.HasCredential = true
			result.Credential = v.Value.(*credential.Provider)
		// Optional pairs
		case "endpoint":
			result.HasEndpoint = true
			result.Endpoint = v.Value.(endpoint.Provider)
		case "http_client_options":
			result.HasHTTPClientOptions = true
			result.HTTPClientOptions = v.Value.(*httpclient.Options)
		case "pair_policy":
			result.HasPairPolicy = true
			result.PairPolicy = v.Value.(PairPolicy)
			// Generated pairs
		}
	}
	if !result.HasCredential {
		return nil, services.NewPairRequiredError("credential")
	}

	return result, nil
}

// pairServiceCreate is the parsed struct
type pairServiceCreate struct {
	pairs []Pair

	// Required pairs
	HasLocation bool
	Location    string
	// Optional pairs
	// Generated pairs
}

// parsePairServiceCreate will parse Pair slice into *pairServiceCreate
func (s *Service) parsePairServiceCreate(opts []Pair) (*pairServiceCreate, error) {
	result := &pairServiceCreate{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		case "location":
			result.HasLocation = true
			result.Location = v.Value.(string)
		// Optional pairs
		// Generated pairs
		default:

			continue

		}
	}
	if !result.HasLocation {
		return nil, services.NewPairRequiredError("location")
	}

	return result, nil
}

// pairServiceDelete is the parsed struct
type pairServiceDelete struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasLocation bool
	Location    string
	// Generated pairs
}

// parsePairServiceDelete will parse Pair slice into *pairServiceDelete
func (s *Service) parsePairServiceDelete(opts []Pair) (*pairServiceDelete, error) {
	result := &pairServiceDelete{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case "location":
			result.HasLocation = true
			result.Location = v.Value.(string)
		// Generated pairs
		default:

			continue

		}
	}

	return result, nil
}

// pairServiceGet is the parsed struct
type pairServiceGet struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasLocation bool
	Location    string
	// Generated pairs
}

// parsePairServiceGet will parse Pair slice into *pairServiceGet
func (s *Service) parsePairServiceGet(opts []Pair) (*pairServiceGet, error) {
	result := &pairServiceGet{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case "location":
			result.HasLocation = true
			result.Location = v.Value.(string)
		// Generated pairs
		default:

			continue

		}
	}

	return result, nil
}

// pairServiceList is the parsed struct
type pairServiceList struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasLocation bool
	Location    string
	// Generated pairs
}

// parsePairServiceList will parse Pair slice into *pairServiceList
func (s *Service) parsePairServiceList(opts []Pair) (*pairServiceList, error) {
	result := &pairServiceList{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case "location":
			result.HasLocation = true
			result.Location = v.Value.(string)
		// Generated pairs
		default:

			continue

		}
	}

	return result, nil
}

// Create will create a new storager instance.
//
// This function will create a context by default.
func (s *Service) Create(name string, pairs ...Pair) (store Storager, err error) {
	ctx := context.Background()
	return s.CreateWithContext(ctx, name, pairs...)
}

// CreateWithContext will create a new storager instance.
func (s *Service) CreateWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	defer func() {
		err = s.formatError("create", err, name)
	}()
	var opt *pairServiceCreate
	opt, err = s.parsePairServiceCreate(pairs)
	if err != nil {
		return
	}

	return s.create(ctx, name, opt)
}

// Delete will delete a storager instance.
//
// This function will create a context by default.
func (s *Service) Delete(name string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, name, pairs...)
}

// DeleteWithContext will delete a storager instance.
func (s *Service) DeleteWithContext(ctx context.Context, name string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("delete", err, name)
	}()
	var opt *pairServiceDelete
	opt, err = s.parsePairServiceDelete(pairs)
	if err != nil {
		return
	}

	return s.delete(ctx, name, opt)
}

// Get will get a valid storager instance for service.
//
// This function will create a context by default.
func (s *Service) Get(name string, pairs ...Pair) (store Storager, err error) {
	ctx := context.Background()
	return s.GetWithContext(ctx, name, pairs...)
}

// GetWithContext will get a valid storager instance for service.
func (s *Service) GetWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	defer func() {
		err = s.formatError("get", err, name)
	}()
	var opt *pairServiceGet
	opt, err = s.parsePairServiceGet(pairs)
	if err != nil {
		return
	}

	return s.get(ctx, name, opt)
}

// List will list all storager instances under this service.
//
// This function will create a context by default.
func (s *Service) List(pairs ...Pair) (sti *StoragerIterator, err error) {
	ctx := context.Background()
	return s.ListWithContext(ctx, pairs...)
}

// ListWithContext will list all storager instances under this service.
func (s *Service) ListWithContext(ctx context.Context, pairs ...Pair) (sti *StoragerIterator, err error) {
	defer func() {

		err = s.formatError("list", err, "")
	}()
	var opt *pairServiceList
	opt, err = s.parsePairServiceList(pairs)
	if err != nil {
		return
	}

	return s.list(ctx, opt)
}

// pairStorageNew is the parsed struct
type pairStorageNew struct {
	pairs []Pair

	// Required pairs
	HasName bool
	Name    string
	// Optional pairs
	HasDisableURICleaning bool
	DisableURICleaning    bool
	HasHTTPClientOptions  bool
	HTTPClientOptions     *httpclient.Options
	HasLocation           bool
	Location              string
	HasPairPolicy         bool
	PairPolicy            PairPolicy
	HasWorkDir            bool
	WorkDir               string
	// Generated pairs
}

// parsePairStorageNew will parse Pair slice into *pairStorageNew
func parsePairStorageNew(opts []Pair) (*pairStorageNew, error) {
	result := &pairStorageNew{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		case "name":
			result.HasName = true
			result.Name = v.Value.(string)
		// Optional pairs
		case "disable_uri_cleaning":
			result.HasDisableURICleaning = true
			result.DisableURICleaning = v.Value.(bool)
		case "http_client_options":
			result.HasHTTPClientOptions = true
			result.HTTPClientOptions = v.Value.(*httpclient.Options)
		case "location":
			result.HasLocation = true
			result.Location = v.Value.(string)
		case "pair_policy":
			result.HasPairPolicy = true
			result.PairPolicy = v.Value.(PairPolicy)
		case "work_dir":
			result.HasWorkDir = true
			result.WorkDir = v.Value.(string)
			// Generated pairs
		}
	}
	if !result.HasName {
		return nil, services.NewPairRequiredError("name")
	}

	return result, nil
}

// pairStorageAbortSegment is the parsed struct
type pairStorageAbortSegment struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageAbortSegment will parse Pair slice into *pairStorageAbortSegment
func (s *Storage) parsePairStorageAbortSegment(opts []Pair) (*pairStorageAbortSegment, error) {
	result := &pairStorageAbortSegment{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.AbortSegment {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageCompleteSegment is the parsed struct
type pairStorageCompleteSegment struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageCompleteSegment will parse Pair slice into *pairStorageCompleteSegment
func (s *Storage) parsePairStorageCompleteSegment(opts []Pair) (*pairStorageCompleteSegment, error) {
	result := &pairStorageCompleteSegment{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.CompleteSegment {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageCopy is the parsed struct
type pairStorageCopy struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageCopy will parse Pair slice into *pairStorageCopy
func (s *Storage) parsePairStorageCopy(opts []Pair) (*pairStorageCopy, error) {
	result := &pairStorageCopy{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Copy {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageDelete is the parsed struct
type pairStorageDelete struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageDelete will parse Pair slice into *pairStorageDelete
func (s *Storage) parsePairStorageDelete(opts []Pair) (*pairStorageDelete, error) {
	result := &pairStorageDelete{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Delete {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageInitIndexSegment is the parsed struct
type pairStorageInitIndexSegment struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageInitIndexSegment will parse Pair slice into *pairStorageInitIndexSegment
func (s *Storage) parsePairStorageInitIndexSegment(opts []Pair) (*pairStorageInitIndexSegment, error) {
	result := &pairStorageInitIndexSegment{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.InitIndexSegment {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageListDir is the parsed struct
type pairStorageListDir struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageListDir will parse Pair slice into *pairStorageListDir
func (s *Storage) parsePairStorageListDir(opts []Pair) (*pairStorageListDir, error) {
	result := &pairStorageListDir{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.ListDir {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageListPrefix is the parsed struct
type pairStorageListPrefix struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageListPrefix will parse Pair slice into *pairStorageListPrefix
func (s *Storage) parsePairStorageListPrefix(opts []Pair) (*pairStorageListPrefix, error) {
	result := &pairStorageListPrefix{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.ListPrefix {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageListPrefixSegments is the parsed struct
type pairStorageListPrefixSegments struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageListPrefixSegments will parse Pair slice into *pairStorageListPrefixSegments
func (s *Storage) parsePairStorageListPrefixSegments(opts []Pair) (*pairStorageListPrefixSegments, error) {
	result := &pairStorageListPrefixSegments{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.ListPrefixSegments {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageMetadata is the parsed struct
type pairStorageMetadata struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageMetadata will parse Pair slice into *pairStorageMetadata
func (s *Storage) parsePairStorageMetadata(opts []Pair) (*pairStorageMetadata, error) {
	result := &pairStorageMetadata{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Metadata {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageMove is the parsed struct
type pairStorageMove struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageMove will parse Pair slice into *pairStorageMove
func (s *Storage) parsePairStorageMove(opts []Pair) (*pairStorageMove, error) {
	result := &pairStorageMove{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Move {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageReach is the parsed struct
type pairStorageReach struct {
	pairs []Pair

	// Required pairs
	HasExpire bool
	Expire    int
	// Optional pairs
	// Generated pairs
}

// parsePairStorageReach will parse Pair slice into *pairStorageReach
func (s *Storage) parsePairStorageReach(opts []Pair) (*pairStorageReach, error) {
	result := &pairStorageReach{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		case "expire":
			result.HasExpire = true
			result.Expire = v.Value.(int)
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Reach {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}
	if !result.HasExpire {
		return nil, services.NewPairRequiredError("expire")
	}

	return result, nil
}

// pairStorageRead is the parsed struct
type pairStorageRead struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasOffset           bool
	Offset              int64
	HasReadCallbackFunc bool
	ReadCallbackFunc    func([]byte)
	HasSize             bool
	Size                int64
	// Generated pairs
}

// parsePairStorageRead will parse Pair slice into *pairStorageRead
func (s *Storage) parsePairStorageRead(opts []Pair) (*pairStorageRead, error) {
	result := &pairStorageRead{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case "offset":
			result.HasOffset = true
			result.Offset = v.Value.(int64)
		case "read_callback_func":
			result.HasReadCallbackFunc = true
			result.ReadCallbackFunc = v.Value.(func([]byte))
		case "size":
			result.HasSize = true
			result.Size = v.Value.(int64)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Read {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageStat is the parsed struct
type pairStorageStat struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageStat will parse Pair slice into *pairStorageStat
func (s *Storage) parsePairStorageStat(opts []Pair) (*pairStorageStat, error) {
	result := &pairStorageStat{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Stat {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageStatistical is the parsed struct
type pairStorageStatistical struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageStatistical will parse Pair slice into *pairStorageStatistical
func (s *Storage) parsePairStorageStatistical(opts []Pair) (*pairStorageStatistical, error) {
	result := &pairStorageStatistical{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Statistical {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// pairStorageWrite is the parsed struct
type pairStorageWrite struct {
	pairs []Pair

	// Required pairs
	HasSize bool
	Size    int64
	// Optional pairs
	HasContentMd5       bool
	ContentMd5          string
	HasContentType      bool
	ContentType         string
	HasOffset           bool
	Offset              int64
	HasReadCallbackFunc bool
	ReadCallbackFunc    func([]byte)
	HasStorageClass     bool
	StorageClass        string
	// Generated pairs
}

// parsePairStorageWrite will parse Pair slice into *pairStorageWrite
func (s *Storage) parsePairStorageWrite(opts []Pair) (*pairStorageWrite, error) {
	result := &pairStorageWrite{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		case "size":
			result.HasSize = true
			result.Size = v.Value.(int64)
		// Optional pairs
		case "content_md5":
			result.HasContentMd5 = true
			result.ContentMd5 = v.Value.(string)
		case "content_type":
			result.HasContentType = true
			result.ContentType = v.Value.(string)
		case "offset":
			result.HasOffset = true
			result.Offset = v.Value.(int64)
		case "read_callback_func":
			result.HasReadCallbackFunc = true
			result.ReadCallbackFunc = v.Value.(func([]byte))
		case "storage_class":
			result.HasStorageClass = true
			result.StorageClass = v.Value.(string)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Write {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}
	if !result.HasSize {
		return nil, services.NewPairRequiredError("size")
	}

	return result, nil
}

// pairStorageWriteIndexSegment is the parsed struct
type pairStorageWriteIndexSegment struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasReadCallbackFunc bool
	ReadCallbackFunc    func([]byte)
	// Generated pairs
}

// parsePairStorageWriteIndexSegment will parse Pair slice into *pairStorageWriteIndexSegment
func (s *Storage) parsePairStorageWriteIndexSegment(opts []Pair) (*pairStorageWriteIndexSegment, error) {
	result := &pairStorageWriteIndexSegment{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case "read_callback_func":
			result.HasReadCallbackFunc = true
			result.ReadCallbackFunc = v.Value.(func([]byte))
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.WriteIndexSegment {
				return nil, services.NewPairUnsupportedError(v)
			}

		}
	}

	return result, nil
}

// AbortSegment will abort a segment.
//
// This function will create a context by default.
func (s *Storage) AbortSegment(seg Segment, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.AbortSegmentWithContext(ctx, seg, pairs...)
}

// AbortSegmentWithContext will abort a segment.
func (s *Storage) AbortSegmentWithContext(ctx context.Context, seg Segment, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("abort_segment", err, seg.Path(), seg.ID())
	}()
	var opt *pairStorageAbortSegment
	opt, err = s.parsePairStorageAbortSegment(pairs)
	if err != nil {
		return
	}

	return s.abortSegment(ctx, seg, opt)
}

// CompleteSegment will complete a segment and merge them into a File.
//
// This function will create a context by default.
func (s *Storage) CompleteSegment(seg Segment, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.CompleteSegmentWithContext(ctx, seg, pairs...)
}

// CompleteSegmentWithContext will complete a segment and merge them into a File.
func (s *Storage) CompleteSegmentWithContext(ctx context.Context, seg Segment, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("complete_segment", err, seg.Path(), seg.ID())
	}()
	var opt *pairStorageCompleteSegment
	opt, err = s.parsePairStorageCompleteSegment(pairs)
	if err != nil {
		return
	}

	return s.completeSegment(ctx, seg, opt)
}

// Copy will copy an Object or multiple object in the service.
//
// This function will create a context by default.
func (s *Storage) Copy(src string, dst string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.CopyWithContext(ctx, src, dst, pairs...)
}

// CopyWithContext will copy an Object or multiple object in the service.
func (s *Storage) CopyWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("copy", err, src, dst)
	}()
	var opt *pairStorageCopy
	opt, err = s.parsePairStorageCopy(pairs)
	if err != nil {
		return
	}

	return s.copy(ctx, src, dst, opt)
}

// Delete will delete an Object from service.
//
// This function will create a context by default.
func (s *Storage) Delete(path string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, path, pairs...)
}

// DeleteWithContext will delete an Object from service.
func (s *Storage) DeleteWithContext(ctx context.Context, path string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("delete", err, path)
	}()
	var opt *pairStorageDelete
	opt, err = s.parsePairStorageDelete(pairs)
	if err != nil {
		return
	}

	return s.delete(ctx, path, opt)
}

// InitIndexSegment will init an index based segment.
//
// This function will create a context by default.
func (s *Storage) InitIndexSegment(path string, pairs ...Pair) (seg Segment, err error) {
	ctx := context.Background()
	return s.InitIndexSegmentWithContext(ctx, path, pairs...)
}

// InitIndexSegmentWithContext will init an index based segment.
func (s *Storage) InitIndexSegmentWithContext(ctx context.Context, path string, pairs ...Pair) (seg Segment, err error) {
	defer func() {
		err = s.formatError("init_index_segment", err, path)
	}()
	var opt *pairStorageInitIndexSegment
	opt, err = s.parsePairStorageInitIndexSegment(pairs)
	if err != nil {
		return
	}

	return s.initIndexSegment(ctx, path, opt)
}

// ListDir will return list a specific dir.
//
// This function will create a context by default.
func (s *Storage) ListDir(dir string, pairs ...Pair) (oi *ObjectIterator, err error) {
	ctx := context.Background()
	return s.ListDirWithContext(ctx, dir, pairs...)
}

// ListDirWithContext will return list a specific dir.
func (s *Storage) ListDirWithContext(ctx context.Context, dir string, pairs ...Pair) (oi *ObjectIterator, err error) {
	defer func() {
		err = s.formatError("list_dir", err, dir)
	}()
	var opt *pairStorageListDir
	opt, err = s.parsePairStorageListDir(pairs)
	if err != nil {
		return
	}

	return s.listDir(ctx, dir, opt)
}

// ListPrefix will return list a specific dir.
//
// This function will create a context by default.
func (s *Storage) ListPrefix(prefix string, pairs ...Pair) (oi *ObjectIterator, err error) {
	ctx := context.Background()
	return s.ListPrefixWithContext(ctx, prefix, pairs...)
}

// ListPrefixWithContext will return list a specific dir.
func (s *Storage) ListPrefixWithContext(ctx context.Context, prefix string, pairs ...Pair) (oi *ObjectIterator, err error) {
	defer func() {
		err = s.formatError("list_prefix", err, prefix)
	}()
	var opt *pairStorageListPrefix
	opt, err = s.parsePairStorageListPrefix(pairs)
	if err != nil {
		return
	}

	return s.listPrefix(ctx, prefix, opt)
}

// ListPrefixSegments will list segments.
//
// This function will create a context by default.
func (s *Storage) ListPrefixSegments(prefix string, pairs ...Pair) (si *SegmentIterator, err error) {
	ctx := context.Background()
	return s.ListPrefixSegmentsWithContext(ctx, prefix, pairs...)
}

// ListPrefixSegmentsWithContext will list segments.
func (s *Storage) ListPrefixSegmentsWithContext(ctx context.Context, prefix string, pairs ...Pair) (si *SegmentIterator, err error) {
	defer func() {
		err = s.formatError("list_prefix_segments", err, prefix)
	}()
	var opt *pairStorageListPrefixSegments
	opt, err = s.parsePairStorageListPrefixSegments(pairs)
	if err != nil {
		return
	}

	return s.listPrefixSegments(ctx, prefix, opt)
}

// Metadata will return current storager's metadata.
//
// This function will create a context by default.
func (s *Storage) Metadata(pairs ...Pair) (meta *StorageMeta, err error) {
	ctx := context.Background()
	return s.MetadataWithContext(ctx, pairs...)
}

// MetadataWithContext will return current storager's metadata.
func (s *Storage) MetadataWithContext(ctx context.Context, pairs ...Pair) (meta *StorageMeta, err error) {
	defer func() {
		err = s.formatError("metadata", err)
	}()
	var opt *pairStorageMetadata
	opt, err = s.parsePairStorageMetadata(pairs)
	if err != nil {
		return
	}

	return s.metadata(ctx, opt)
}

// Move will move an object in the service.
//
// This function will create a context by default.
func (s *Storage) Move(src string, dst string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.MoveWithContext(ctx, src, dst, pairs...)
}

// MoveWithContext will move an object in the service.
func (s *Storage) MoveWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("move", err, src, dst)
	}()
	var opt *pairStorageMove
	opt, err = s.parsePairStorageMove(pairs)
	if err != nil {
		return
	}

	return s.move(ctx, src, dst, opt)
}

// Reach will provide a way, which can reach the object.
//
// This function will create a context by default.
func (s *Storage) Reach(path string, pairs ...Pair) (url string, err error) {
	ctx := context.Background()
	return s.ReachWithContext(ctx, path, pairs...)
}

// ReachWithContext will provide a way, which can reach the object.
func (s *Storage) ReachWithContext(ctx context.Context, path string, pairs ...Pair) (url string, err error) {
	defer func() {
		err = s.formatError("reach", err, path)
	}()
	var opt *pairStorageReach
	opt, err = s.parsePairStorageReach(pairs)
	if err != nil {
		return
	}

	return s.reach(ctx, path, opt)
}

// Read will read the file's data.
//
// This function will create a context by default.
func (s *Storage) Read(path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.ReadWithContext(ctx, path, w, pairs...)
}

// ReadWithContext will read the file's data.
func (s *Storage) ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	defer func() {
		err = s.formatError("read", err, path)
	}()
	var opt *pairStorageRead
	opt, err = s.parsePairStorageRead(pairs)
	if err != nil {
		return
	}

	return s.read(ctx, path, w, opt)
}

// Stat will stat a path to get info of an object.
//
// This function will create a context by default.
func (s *Storage) Stat(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.StatWithContext(ctx, path, pairs...)
}

// StatWithContext will stat a path to get info of an object.
func (s *Storage) StatWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err = s.formatError("stat", err, path)
	}()
	var opt *pairStorageStat
	opt, err = s.parsePairStorageStat(pairs)
	if err != nil {
		return
	}

	return s.stat(ctx, path, opt)
}

// Statistical will count service's statistics, such as Size, Count.
//
// This function will create a context by default.
func (s *Storage) Statistical(pairs ...Pair) (statistic *StorageStatistic, err error) {
	ctx := context.Background()
	return s.StatisticalWithContext(ctx, pairs...)
}

// StatisticalWithContext will count service's statistics, such as Size, Count.
func (s *Storage) StatisticalWithContext(ctx context.Context, pairs ...Pair) (statistic *StorageStatistic, err error) {
	defer func() {
		err = s.formatError("statistical", err)
	}()
	var opt *pairStorageStatistical
	opt, err = s.parsePairStorageStatistical(pairs)
	if err != nil {
		return
	}

	return s.statistical(ctx, opt)
}

// Write will write data into a file.
//
// This function will create a context by default.
func (s *Storage) Write(path string, r io.Reader, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteWithContext(ctx, path, r, pairs...)
}

// WriteWithContext will write data into a file.
func (s *Storage) WriteWithContext(ctx context.Context, path string, r io.Reader, pairs ...Pair) (n int64, err error) {
	defer func() {
		err = s.formatError("write", err, path)
	}()
	var opt *pairStorageWrite
	opt, err = s.parsePairStorageWrite(pairs)
	if err != nil {
		return
	}

	return s.write(ctx, path, r, opt)
}

// WriteIndexSegment will write a part into an index based segment.
//
// This function will create a context by default.
func (s *Storage) WriteIndexSegment(seg Segment, r io.Reader, index int, size int64, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.WriteIndexSegmentWithContext(ctx, seg, r, index, size, pairs...)
}

// WriteIndexSegmentWithContext will write a part into an index based segment.
func (s *Storage) WriteIndexSegmentWithContext(ctx context.Context, seg Segment, r io.Reader, index int, size int64, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("write_index_segment", err, seg.Path(), seg.ID())
	}()
	var opt *pairStorageWriteIndexSegment
	opt, err = s.parsePairStorageWriteIndexSegment(pairs)
	if err != nil {
		return
	}

	return s.writeIndexSegment(ctx, seg, r, index, size, opt)
}
